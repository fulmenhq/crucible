# Release Notes: v0.2.14

**Date**: 2025-11-15

Dual-feature release achieving cross-language type system parity through TypeScript enum generation AND establishing canonical DevSecOps secrets management infrastructure. TypeScript code generation migrates from string literal unions to proper enums (matching Go/Python patterns), plus structured error interfaces. New project secrets schema enables secure environment variable management with encryption support (GPG/age/passphrase), policy enforcement, and comprehensive tooling foundation for fulmen-secrets (fulsecrets) CLI.

## Highlights

### TypeScript Enum Generation

- **TypeScript Enums**: Generates proper enums instead of string literal unions for fulpack and fulencode modules
- **Cross-Language Parity**: All three languages (Go, Python, TypeScript) now use equivalent enum-style types
- **Structured Error Interface**: New `FulpackError` interface replaces `string[]` with rich context (code, message, operation, path, details)
- **TSFulmen Unblocked**: Resolves 33 type errors in tsfulmen's 583-line implementation that expected enums
- **Non-Breaking**: No implementations exist yet (fulpack v0.2.11, fulencode v0.2.12 only provided types)

### DevSecOps Project Secrets Schema (NEW)

- **Canonical Schema**: First-class SSOT for project-scoped secrets files with encryption metadata
- **Dual-Mode Design**: Plaintext (development) OR encrypted (production) with schema-enforced mutual exclusivity
- **Encryption Support**: GPG, age, and passphrase-based encryption with roundtrip plaintext ↔ ciphertext
- **Policy Enforcement**: `allow_plain_secrets: false` enables "FIPS mode" / compliance workflows
- **Comprehensive Documentation**: 783-line standard with security best practices, CLI integration patterns, troubleshooting
- **Fulsecrets Ready**: Enables fulmen-secrets (fulsecrets) CLI tool v0.1.0 development (launching alongside gofulmen v0.2.14)

## What's New

### TypeScript Enum Generation

TypeScript code generation now produces proper TypeScript enums instead of string literal unions, achieving cross-language parity with Go (typed constants) and Python (Enum classes).

#### Before (v0.2.13 and earlier):

```typescript
// String literal union (weak typing)
export type ArchiveFormat = "tar" | "tar.gz" | "zip" | "gzip";

export type Operation = "create" | "extract" | "scan" | "verify" | "info";

// Usage
const format: ArchiveFormat = "tar.gz"; // String literal
```

#### After (v0.2.14):

```typescript
// TypeScript enum (strong typing)
export enum ArchiveFormat {
  /** POSIX tar archive (uncompressed) */
  TAR = "tar",
  /** POSIX tar archive with gzip compression */
  TAR_GZ = "tar.gz",
  /** ZIP archive with deflate compression */
  ZIP = "zip",
  /** GZIP compressed single file */
  GZIP = "gzip",
}

export enum Operation {
  /** Create new archive from source files/directories */
  CREATE = "create",
  /** Extract archive contents to destination */
  EXTRACT = "extract",
  /** List archive entries (for Pathfinder integration) */
  SCAN = "scan",
  /** Validate archive integrity and checksums */
  VERIFY = "verify",
  /** Get archive metadata without extraction */
  INFO = "info",
}

// Usage
const format: ArchiveFormat = ArchiveFormat.TAR_GZ; // Enum member
```

#### Benefits

1. **Refactoring Safety**: IDEs can safely rename enum members across entire codebase
2. **Autocomplete**: IntelliSense shows all valid values with documentation
3. **Exhaustiveness Checking**: TypeScript compiler enforces switch statement coverage
4. **Reverse Lookups**: `ArchiveFormat[ArchiveFormat.TAR_GZ] === "TAR_GZ"` for debugging
5. **Runtime Validation**: Enum members can be introspected at runtime
6. **Cross-Language Parity**: Matches Go's typed constants and Python's Enum classes

#### Constant Naming

Enum constant names follow `SCREAMING_SNAKE_CASE` convention with special character transformation:

| Taxonomy Value       | Enum Constant Name | Transformation Rule                     |
| -------------------- | ------------------ | --------------------------------------- |
| `"tar"`              | `TAR`              | Simple uppercase                        |
| `"tar.gz"`           | `TAR_GZ`           | Dots → underscores                      |
| `"utf-8"`            | `UTF_8`            | Hyphens → underscores                   |
| `"iso-8859-1"`       | `ISO_8859_1`       | Multiple hyphens → multiple underscores |
| `"base64url"`        | `BASE64URL`        | Alphanumeric preserved                  |
| `"safe_identifiers"` | `SAFE_IDENTIFIERS` | Underscores preserved                   |

**Implementation**: Uses existing `toConstantCase()` helper: `.toUpperCase().replace(/[.\-]/g, "_")`

#### Affected Modules

**Fulpack Enums** (`lang/typescript/src/fulpack/types.ts`):

- `ArchiveFormat`: 4 members (TAR, TAR_GZ, ZIP, GZIP)
- `EntryType`: 3 members (FILE, DIRECTORY, SYMLINK)
- `Operation`: 5 members (CREATE, EXTRACT, SCAN, VERIFY, INFO)

**Fulencode Enums** (`lang/typescript/src/fulencode/types.ts`):

- `EncodingFormat`: 12 members (BASE64, BASE64URL, BASE64_RAW, BASE32, BASE32HEX, HEX, UTF_8, UTF_16LE, UTF_16BE, ISO_8859_1, CP1252, ASCII)
- `NormalizationProfile`: 8 members (NFC, NFD, NFKC, NFKD, SAFE_IDENTIFIERS, SEARCH_OPTIMIZED, FILENAME_SAFE, LEGACY_COMPATIBLE)
- `ConfidenceLevel`: 3 members (HIGH, MEDIUM, LOW)

### Fulpack Structured Error Interface

New `FulpackError` interface replaces simple `string[]` errors with rich structured context, enabling better observability and programmatic error handling.

#### Interface Definition

```typescript
/**
 * Structured error context for fulpack operations.
 * Enables programmatic error handling and observability.
 *
 * @see docs/standards/library/modules/fulpack.md
 */
export interface FulpackError {
  /**
   * Canonical error code for programmatic handling.
   * Examples: "PATH_TRAVERSAL", "DECOMPRESSION_BOMB", "ABSOLUTE_PATH", "SYMLINK_ESCAPE"
   */
  readonly code: string;

  /**
   * Human-readable error message describing what went wrong.
   */
  readonly message: string;

  /**
   * Operation that generated this error.
   */
  readonly operation: Operation;

  /**
   * Entry path that caused the error (if applicable).
   * Example: "../../../etc/passwd"
   */
  readonly path?: string;

  /**
   * Archive file path being processed.
   */
  readonly archive?: string;

  /**
   * Source file path for create operations.
   */
  readonly source?: string;

  /**
   * Additional structured context for debugging and telemetry.
   */
  readonly details?: {
    /** Entry index in archive (0-based) */
    readonly entry_index?: number;
    /** Compression ratio that triggered bomb detection */
    readonly compression_ratio?: number;
    /** Actual decompressed size in bytes */
    readonly actual_size?: number;
    /** Maximum allowed size in bytes */
    readonly max_size?: number;
    /** Maximum allowed entries */
    readonly max_entries?: number;
    /** Actual entry count */
    readonly entry_count?: number;
    /** Additional context (extensible) */
    readonly [key: string]: unknown;
  };
}
```

#### Updated Interfaces

**ValidationResult** (`lang/typescript/src/fulpack/types.ts:181-193`):

```typescript
export interface ValidationResult {
  readonly valid: boolean;
  readonly errors: FulpackError[]; // Changed from string[]
  readonly warnings: string[];
  readonly entry_count: number;
  readonly checksums_verified?: number;
  readonly checks_performed?:
    | "structure_valid"
    | "checksums_verified"
    | "no_path_traversal"
    | "no_decompression_bomb"
    | "symlinks_safe"[];
}
```

**ExtractResult** (`lang/typescript/src/fulpack/types.ts:199-207`):

```typescript
export interface ExtractResult {
  readonly extracted_count: number;
  readonly skipped_count: number;
  readonly error_count: number;
  readonly errors?: FulpackError[]; // Changed from string[]
  readonly warnings?: string[];
  readonly checksums_verified?: number;
  readonly total_bytes?: number;
}
```

#### Example Usage

**Before (v0.2.13 and earlier)**:

```typescript
const result = await verify("archive.tar.gz");
if (!result.valid) {
  console.error("Validation failed:", result.errors); // string[]
  // No structured context for observability
}
```

**After (v0.2.14)**:

```typescript
const result = await verify("archive.tar.gz");
if (!result.valid) {
  result.errors.forEach((error) => {
    // Programmatic error handling
    if (error.code === "PATH_TRAVERSAL") {
      console.error(`Path traversal detected: ${error.path}`);
      telemetry.recordSecurityViolation("path_traversal", {
        operation: error.operation,
        archive: error.archive,
        entry_index: error.details?.entry_index,
      });
    } else if (error.code === "DECOMPRESSION_BOMB") {
      console.error(`Decompression bomb detected: ${error.message}`);
      telemetry.recordSecurityViolation("decompression_bomb", {
        compression_ratio: error.details?.compression_ratio,
        actual_size: error.details?.actual_size,
        max_size: error.details?.max_size,
      });
    }
  });
}
```

#### Benefits

1. **Telemetry Categorization**: Error codes enable grouping in observability dashboards
2. **Programmatic Handling**: Switch on `error.code` for specific error handling logic
3. **Rich Context**: Path, archive, source, details provide debugging information
4. **Type Safety**: TypeScript validates error structure at compile time
5. **Extensibility**: `details[key: string]` allows future expansion without breaking changes
6. **Cross-Language Alignment**: Mirrors Go and Python structured error patterns

### Cross-Language Type Parity

All three languages now use equivalent enum-style types:

**TypeScript** (v0.2.14):

```typescript
export enum ArchiveFormat {
  TAR = "tar",
  TAR_GZ = "tar.gz",
  ZIP = "zip",
  GZIP = "gzip",
}
```

**Go** (gofulmen, since v0.2.11):

```go
type ArchiveFormat string

const (
    ArchiveFormatTAR    ArchiveFormat = "tar"
    ArchiveFormatTARGZ  ArchiveFormat = "tar.gz"
    ArchiveFormatZIP    ArchiveFormat = "zip"
    ArchiveFormatGZIP   ArchiveFormat = "gzip"
)
```

**Python** (pyfulmen, since v0.2.11):

```python
class ArchiveFormat(str, Enum):
    TAR = "tar"
    TAR_GZ = "tar.gz"
    ZIP = "zip"
    GZIP = "gzip"
```

**Behavioral Alignment**:

- All three serialize to the same JSON string values (`"tar"`, `"tar.gz"`, etc.)
- All three provide IDE autocomplete and type checking
- All three enable exhaustiveness checking in switch/match statements
- All three support reverse lookups for debugging
- **Result**: Cross-language implementations have identical API ergonomics

### DevSecOps Project Secrets Schema

Canonical schema establishing SSOT for project-scoped secrets management with encryption support, enabling fulmen-secrets (fulsecrets) CLI tool and DevSecOps microtools integration.

#### Schema Overview

**Location**: `schemas/devsecops/secrets/v1.0.0/secrets.schema.json`

**Purpose**: Define standardized format for managing environment variables across development, staging, and production with encryption support and policy enforcement.

**Key Features**:

- **Dual-mode design**: Plaintext (development) OR encrypted (production) - mutually exclusive via `oneOf` validation
- **Project scoping**: Multiple projects in single file with `project_slug` filtering
- **Encryption metadata**: Tracks method (gpg/age/passphrase), key_id, timestamp, cipher algorithm
- **Policy enforcement**: `allow_plain_secrets: false` for compliance/"FIPS mode"
- **Security-first**: Schema validates against common vulnerabilities (plaintext leaks, missing encryption in prod)

#### Files Delivered

| File                                                   | Lines | Purpose                                                     |
| ------------------------------------------------------ | ----- | ----------------------------------------------------------- |
| `schemas/devsecops/secrets/v1.0.0/secrets.schema.json` | 250   | JSON Schema with dual-mode validation (plaintext/encrypted) |
| `config/devsecops/secrets/v1.0.0/defaults.yaml`        | 198   | Sample configs (dev/prod examples, all encryption methods)  |
| `docs/standards/devsecops/project-secrets.md`          | 783   | Comprehensive standard with security best practices         |

#### Schema Structure (Plaintext Mode)

```yaml
schema_version: v1.0.0

projects:
  - project_slug: myapp-prod # Slugified identifier (lowercase + hyphens)
    env_prefix: APP_ # Optional prefix for all vars
    secrets:
      DATABASE_URL: postgres://... # Key-value pairs (flat strings only)
      API_KEY: sk_live_...

policies:
  allow_plain_secrets: false # Reject plaintext for production
```

**Constraints**:

- `project_slug`: Must match `^[a-z0-9]+(-[a-z0-9]+)*$` (1-64 chars)
- `secrets` keys: Must be `UPPER_SNAKE_CASE` (valid env var names)
- `secrets` values: **Flat strings only** - no nested objects in v1.0.0

#### Schema Structure (Encrypted Mode)

```yaml
schema_version: v1.0.0

encryption:
  method: gpg # gpg | age | passphrase
  key_id: 7A8B9C0D1E2F3A4B # GPG fingerprint or age public key
  encrypted_at: "2025-11-15T10:00:00Z"
  cipher: AES-256-GCM # Optional but recommended

ciphertext: | # Encrypted projects array
  -----BEGIN PGP MESSAGE-----
  hQIMA3xQvBF2g8NSAQ//ZQWJRW8F...
  -----END PGP MESSAGE-----

policies:
  allow_plain_secrets: false
```

**When encrypted**:

- `projects` array is NOT present (replaced by `ciphertext`)
- Encryption metadata required (`method`, `encrypted_at`)
- Schema enforces mutual exclusivity via `oneOf`

#### Encryption Methods Supported

**1. GPG (GNU Privacy Guard)**

- **Use case**: Teams with existing GPG infrastructure
- **Multi-recipient**: Future v0.2.0 (enables team key rotation)
- **Example**: `fulsecrets encrypt secrets.yaml --gpg-key team@example.com`

**2. Age (Modern Alternative)**

- **Use case**: Greenfield projects, simpler key management
- **Key generation**: `age-keygen -o ~/.config/fulsecrets/key.txt`
- **Example**: `fulsecrets encrypt secrets.yaml --age-recipient age1ql3z...`

**3. Passphrase (Symmetric)**

- **Use case**: Solo developers, simplest setup
- **No keys**: Just strong passphrase via password manager
- **Example**: `fulsecrets encrypt secrets.yaml --passphrase`

#### CLI Integration Pattern (fulsecrets)

**Subprocess Wrapping** (recommended - secrets never touch shell):

```bash
# Load secrets and run command (secrets isolated to subprocess)
fulsecrets exec -p myapp-prod -- npm start

# Multi-project merge (future v0.2.0)
fulsecrets exec -p api-prod -p worker-prod -- ./deploy.sh
```

**NOT recommended** (eval pattern exposes secrets):

```bash
# ❌ BAD - secrets in shell history, ps aux, process listing
eval $(fulsecrets load myapp-prod)
npm start
```

#### Policy Enforcement Example

**Production file with encryption required**:

```yaml
policies:
  allow_plain_secrets: false  # Reject plaintext

# Attempting to use plaintext with this policy:
$ fulsecrets validate secrets-prod.yaml --strict
❌ Error: Policy violation: allow_plain_secrets is false but file is not encrypted
```

**Pre-commit hook example**:

```bash
#!/bin/bash
# Ensure production secrets are encrypted
if [[ "$file" =~ prod ]]; then
  if ! grep -q "^encryption:" "$file"; then
    echo "❌ Production secrets must be encrypted: $file"
    exit 1
  fi
fi
```

#### Use Cases

**Development**: Plaintext local secrets for rapid iteration

```bash
fulsecrets exec -p myapp-dev -- npm run dev
```

**Staging/Production**: Encrypted secrets with team access

```bash
# Prompts for GPG passphrase, decrypts in memory, runs command
fulsecrets exec -p myapp-prod -- python app.py
```

**CI/CD**: Passphrase from GitHub Secrets, no interactive prompts

```yaml
env:
  FULSECRETS_PASSPHRASE: ${{ secrets.FULSECRETS_PASSPHRASE }}
run: fulsecrets exec -p myapp-prod --passphrase -- ./deploy.sh
```

**Compliance**: FIPS mode enforcement via policy

```yaml
policies:
  allow_plain_secrets: false # Schema validation fails if not encrypted
```

#### v1.0.0 Scope

**Included**:

- ✅ Project scoping via `project_slug`
- ✅ Simple key-value secrets (string → string)
- ✅ Encryption metadata (method, key_id, encrypted_at, cipher)
- ✅ Dual-mode schema (plaintext OR encrypted, mutually exclusive)
- ✅ Policy enforcement (`allow_plain_secrets`)

**Explicitly Deferred to v1.1.0**:

- ❌ Reference-based secrets (e.g., `{ref: "vault://path"}`, `{ref: "turso://db/key"}`)
- ❌ Expiry/rotation metadata (`expires_at`, `rotation_interval`)
- ❌ Audit tags and telemetry integration
- ❌ Nested secret values (complex objects)

**Rationale**: Start simple, iterate based on real fulsecrets v0.1.0 usage. Reference-based secrets and expiry metadata will be added in v1.1.0 after implementation feedback from fulmen-secrets (fulsecrets) tool and DevSecOps teams.

#### Fulsecrets Team Feedback

> "Strong generalization—secrets.schema.json (v1.0.0) is a clean, extensible SSOT for project-scoped key-value configs (plaintext/encrypted modes via oneOf, with GPG/age/passphrase support, policies for enforcement) that fits any FulmenHQ tool, not just etknow. Defaults.yaml provides practical examples/templates (dev/prod, multi-project) and best practices (shred plaintext, CI/CD integration), aligning perfectly with our microtool flow (generate from schema, encrypt/shred, unseal/load). Minor gap: No built-in refs (e.g., Turso) or metadata (expiry)—propose v1.1.0 addition."
>
> — Fulsecrets Team, 2025-11-15

**Team is proceeding with fulsecrets v0.1.0 implementation based on this schema.**

## Migration Guide

### For Helper Library Implementers

**TypeScript Implementations** (tsfulmen):

#### 1. Update Import Style

**Before (v0.2.13)**:

```typescript
import type { ArchiveFormat, Operation } from "crucible/fulpack";

const format: ArchiveFormat = "tar.gz"; // String literal
const op: Operation = "extract"; // String literal
```

**After (v0.2.14)**:

```typescript
import { ArchiveFormat, Operation } from "crucible/fulpack"; // Remove 'type' keyword

const format: ArchiveFormat = ArchiveFormat.TAR_GZ; // Enum member
const op: Operation = Operation.EXTRACT; // Enum member
```

**Note**: You can still use string literals due to TypeScript's structural typing, but enums provide better type safety and IDE support.

#### 2. Update Function Signatures (No Changes Required)

Function signatures remain compatible due to TypeScript's structural typing:

```typescript
// This still works without changes
export async function create(
  source: string,
  archive: string,
  format: ArchiveFormat, // Accepts both enum members and string literals
  options?: CreateOptions,
): Promise<void>;

// Both valid:
await create("src/", "archive.tar.gz", ArchiveFormat.TAR_GZ); // Enum member
await create("src/", "archive.tar.gz", "tar.gz"); // String literal (backward compatible)
```

#### 3. Update Error Handling

**Before (v0.2.13)**:

```typescript
const result = await verify("archive.tar.gz");
if (!result.valid) {
  result.errors.forEach((error: string) => {
    console.error(error); // Simple string
  });
}
```

**After (v0.2.14)**:

```typescript
const result = await verify("archive.tar.gz");
if (!result.valid) {
  result.errors.forEach((error) => {
    // Now FulpackError with structured context
    console.error(`[${error.code}] ${error.message}`);
    if (error.path) console.error(`  Path: ${error.path}`);
    if (error.details) console.error(`  Details:`, error.details);
  });
}
```

#### 4. Enable Exhaustiveness Checking

```typescript
function getFormatDescription(format: ArchiveFormat): string {
  switch (format) {
    case ArchiveFormat.TAR:
      return "Uncompressed tar archive";
    case ArchiveFormat.TAR_GZ:
      return "Compressed tar.gz archive";
    case ArchiveFormat.ZIP:
      return "ZIP archive";
    case ArchiveFormat.GZIP:
      return "GZIP compressed file";
    default:
      // TypeScript will error if any enum member is missing
      const exhaustiveCheck: never = format;
      throw new Error(`Unhandled format: ${exhaustiveCheck}`);
  }
}
```

#### 5. Update Tests

```typescript
import { ArchiveFormat, Operation } from "crucible/fulpack";

test("create operation produces tar.gz archive", async () => {
  await create("src/", "test.tar.gz", ArchiveFormat.TAR_GZ);
  const info = await info("test.tar.gz");
  expect(info.format).toBe(ArchiveFormat.TAR_GZ); // Or "tar.gz" (both work)
});

test("structured errors include operation context", async () => {
  const result = await verify("pathological.tar.gz");
  expect(result.valid).toBe(false);
  expect(result.errors.length).toBeGreaterThan(0);
  expect(result.errors[0]).toMatchObject({
    code: expect.any(String),
    message: expect.any(String),
    operation: Operation.VERIFY,
  });
});
```

### For Fulencode Implementations

Same migration pattern applies to fulencode types:

```typescript
import { EncodingFormat, NormalizationProfile } from "crucible/fulencode";

// Before
const encoding: EncodingFormat = "utf-8";
const profile: NormalizationProfile = "nfc";

// After
const encoding: EncodingFormat = EncodingFormat.UTF_8;
const profile: NormalizationProfile = NormalizationProfile.NFC;
```

### Backward Compatibility

**String Literals Still Accepted**: Due to TypeScript's structural typing, string literals are still accepted:

```typescript
// All valid (but enums preferred):
const format1: ArchiveFormat = ArchiveFormat.TAR_GZ; // ✅ Preferred (enum member)
const format2: ArchiveFormat = "tar.gz"; // ✅ Acceptable (string literal)
const format3 = ArchiveFormat.TAR_GZ; // ✅ Best (inferred enum type)

// JSON deserialization still works:
const json = '{"format":"tar.gz"}';
const obj: { format: ArchiveFormat } = JSON.parse(json); // ✅ Still valid
```

**Migration Strategy**: You can migrate incrementally without breaking existing code.

## Technical Details

### Code Generation Changes

**Template Modifications**:

1. **`scripts/codegen/fulpack-types/typescript/types.template.ejs`**:
   - Changed enum generation from string unions to TypeScript enums (lines 14-28)
   - Added `FulpackError` interface with structured fields (lines 29-91)
   - Added conditional field type override for `errors` field in `ValidationResult` and `ExtractResult` (lines 103-117)

2. **`scripts/codegen/fulencode-types/typescript/types.template.ejs`**:
   - Changed enum generation from string unions to TypeScript enums (lines 14-28)

**Constant Name Transformation**:

Uses existing `toConstantCase()` helper function:

```typescript
function toConstantCase(name: string): string {
  return name.toUpperCase().replace(/[.\-]/g, "_");
}
```

**Examples**:

- `"tar"` → `"TAR"`
- `"tar.gz"` → `"TAR_GZ"`
- `"utf-8"` → `"UTF_8"`
- `"iso-8859-1"` → `"ISO_8859_1"`
- `"safe_identifiers"` → `"SAFE_IDENTIFIERS"`

### Generated Output

**File Locations**:

- `lang/typescript/src/fulpack/types.ts` (264 lines)
- `lang/typescript/src/fulencode/types.ts` (93 lines)

**Verification**:

```bash
# TypeScript compilation
bunx tsc --noEmit
# ✅ Passed - no type errors

# Code generation drift detection
make verify-codegen
# ✅ Passed - templates match generated output
```

### EJS Template Logic

**Conditional Field Type Override**:

```ejs
<% data_structures.forEach(schema => { %>
export interface <%- schema.className %> {
<% schema.required_properties.forEach(prop => { %><%
  // Override errors field to use FulpackError[] for ValidationResult and ExtractResult
  let fieldType = prop.typescript_type;
  if (prop.name === 'errors' && (schema.className === 'ValidationResult' || schema.className === 'ExtractResult')) {
    fieldType = 'FulpackError[]';
  }
%>  readonly <%- prop.name %>: <%- fieldType %>;<% if (prop.description) { %> // <%- prop.description %><% } %>
<% }); %>}
<% }); %>
```

**Rationale**: Avoids schema changes by overriding field types in template logic.

## Breaking Changes

**Type-level changes only** (marked as breaking for semver compliance):

### Changed Type Definitions

1. **Enums**: `ArchiveFormat`, `EntryType`, `Operation` (fulpack) and `EncodingFormat`, `NormalizationProfile`, `ConfidenceLevel` (fulencode) changed from string unions to enums
2. **Error Fields**: `ValidationResult.errors` and `ExtractResult.errors` changed from `string[]` to `FulpackError[]`

### Non-Breaking in Practice

**Why this is non-breaking**:

1. **No implementations exist yet**:
   - Fulpack v0.2.11 only provided types (no tsfulmen implementation shipped)
   - Fulencode v0.2.12 only provided types (no implementations shipped)
   - This release updates types before any implementations, avoiding runtime breaks

2. **TypeScript structural typing**:
   - String literals still assignable to enums due to structural typing
   - Existing code using string literals will continue to compile

3. **JSON compatibility**:
   - Enums serialize to same string values as before
   - JSON deserialization still works without changes

**Impact**: Implementations using the old types will see compile-time warnings but no runtime errors. Migration is straightforward (see Migration Guide).

## Deprecations

None.

## Known Issues

None.

## Contributors

Generated by Schema Cartographer ([Claude Code](https://claude.com/claude-code)) under supervision of @3leapsdave.

Co-Authored-By: Schema Cartographer <noreply@3leaps.net>

## What's Next

**v0.2.15** (Planned):

- Fulencode helper library implementations (gofulmen, pyfulmen, tsfulmen)
- Fulpack helper library implementations completed (gofulmen, pyfulmen, tsfulmen)
- Nimbus module specification (cloud storage operations)
- Additional foundry catalog expansions

**Feedback**: Report issues at https://github.com/fulmenhq/crucible/issues

---

**Full Changelog**: https://github.com/fulmenhq/crucible/blob/main/CHANGELOG.md
